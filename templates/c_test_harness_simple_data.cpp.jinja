#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include "doctest.h" // Corrected include path

#include "cbor_generated.h"
#include "{{ input_header_path }}" // Include the original header for struct definitions
#include <string.h> // For strcmp, etc.
#include <stdlib.h> // For malloc/free for char* members

// Define a buffer for CBOR encoding/decoding
#define CBOR_BUFFER_SIZE 512 // Increased buffer size for nested data
static uint8_t cbor_buffer[CBOR_BUFFER_SIZE];

DOCTEST_TEST_CASE("SimpleData encoding and decoding") {
    struct SimpleData original_data = {
        .id = 12345,
        .is_active = true,
        .temperature = 25.5f,
        .flags = {1, 2, 3, 4}
    };
    strncpy(original_data.name, "Test Name", sizeof(original_data.name) - 1);
    original_data.name[sizeof(original_data.name) - 1] = '\0';

    CborEncoder encoder;
    cbor_encoder_init(&encoder, cbor_buffer, sizeof(cbor_buffer), 0);

    bool encode_ok = encode_SimpleData(&original_data, &encoder);
    REQUIRE(encode_ok); // Use REQUIRE to stop if encoding fails

    size_t encoded_len = cbor_encoder_get_buffer_size(&encoder, cbor_buffer);
    DOCTEST_MESSAGE("SimpleData encoded successfully. Encoded size: ", encoded_len, " bytes");

    struct SimpleData decoded_data;
    memset(&decoded_data, 0, sizeof(decoded_data)); // Initialize to zero

    CborParser parser;
    CborValue it;
    CborError err = cbor_parser_init(cbor_buffer, encoded_len, 0, &parser, &it);
    REQUIRE(err == CborNoError); // Use REQUIRE to stop if parser init fails

    bool decode_ok = decode_SimpleData(&decoded_data, &it);
    REQUIRE(decode_ok); // Use REQUIRE to stop if decoding fails

    DOCTEST_MESSAGE("SimpleData decoded successfully.");

    // Assertions
    CHECK(decoded_data.id == original_data.id);
    CHECK(strcmp(decoded_data.name, original_data.name) == 0);
    CHECK(decoded_data.is_active == original_data.is_active);
    // Use doctest::Approx for float comparison
    CHECK(decoded_data.temperature == doctest::Approx(original_data.temperature));
    for (int i = 0; i < 4; ++i) {
        CHECK(decoded_data.flags[i] == original_data.flags[i]);
    }
}

// Test case for NestedData (requires manual char* allocation for description)
DOCTEST_TEST_CASE("NestedData encoding and decoding") {
    // Original data
    struct NestedData original_nested_data = {
        .inner_data = {
            .id = 54321,
            .is_active = false,
            .temperature = 99.9f,
            .flags = {5, 6, 7, 8}
        },
        .value = 789
    };
    strncpy(original_nested_data.inner_data.name, "Nested Name", sizeof(original_nested_data.inner_data.name) - 1);
    original_nested_data.inner_data.name[sizeof(original_nested_data.inner_data.name) - 1] = '\0';

    const char* original_description_str = "This is a test description for NestedData.";
    original_nested_data.description = (char*)original_description_str; // Point to a const string for encoding

    CborEncoder encoder;
    cbor_encoder_init(&encoder, cbor_buffer, sizeof(cbor_buffer), 0);

    bool encode_ok = encode_NestedData(&original_nested_data, &encoder);
    REQUIRE(encode_ok);

    size_t encoded_len = cbor_encoder_get_buffer_size(&encoder, cbor_buffer);
    DOCTEST_MESSAGE("Encoded NestedData size: ", encoded_len, " bytes");

    // Decode
    struct NestedData decoded_nested_data;
    memset(&decoded_nested_data, 0, sizeof(decoded_nested_data));

    // IMPORTANT: For char* members, you must allocate memory before decoding!
    // The decode_char_ptr helper assumes the pointer is already pointing to a valid buffer.
    // The hardcoded '256' in the template is a placeholder for max_len.
    decoded_nested_data.description = (char*)malloc(256); // Allocate enough space
    REQUIRE(decoded_nested_data.description != NULL);

    CborParser parser;
    CborValue it;
    CborError err = cbor_parser_init(cbor_buffer, encoded_len, 0, &parser, &it);
    REQUIRE(err == CborNoError);

    bool decode_ok = decode_NestedData(&decoded_nested_data, &it);
    REQUIRE(decode_ok);

    DOCTEST_MESSAGE("NestedData decoded successfully.");

    // Assertions for NestedData
    CHECK(decoded_nested_data.value == original_nested_data.value);
    CHECK(strcmp(decoded_nested_data.description, original_nested_data.description) == 0);

    // Assertions for nested SimpleData
    CHECK(decoded_nested_data.inner_data.id == original_nested_data.inner_data.id);
    CHECK(strcmp(decoded_nested_data.inner_data.name, original_nested_data.inner_data.name) == 0);
    CHECK(decoded_nested_data.inner_data.is_active == original_nested_data.inner_data.is_active);
    CHECK(decoded_nested_data.inner_data.temperature == doctest::Approx(original_nested_data.inner_data.temperature));
    for (int i = 0; i < 4; ++i) {
        CHECK(decoded_nested_data.inner_data.flags[i] == original_nested_data.inner_data.flags[i]);
    }

    free(decoded_nested_data.description); // Free allocated memory
}
