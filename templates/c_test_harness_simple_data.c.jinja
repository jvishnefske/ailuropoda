#include "cbor_generated.h"
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <assert.h>
#include <math.h> // For fabs

// Define a max length for char* members for decoding purposes in the test harness
// This must be at least as large as the hardcoded value (256) used in cbor_generated.c.jinja
#define MAX_DESCRIPTION_LEN 256

// Helper to print CBOR data (for debugging)
void print_cbor_hex(const uint8_t* buffer, size_t len) {
    printf("CBOR Hex: ");
    for (size_t i = 0; i < len; ++i) {
        printf("%02X ", buffer[i]);
    }
    printf("\n");
}

int main() {
    // --- Test SimpleData ---
    struct SimpleData original_simple = {
        .id = 123,
        .is_active = true,
        .temperature = 25.5f,
        .flags = {0x01, 0x02, 0x03, 0x04}
    };
    strncpy(original_simple.name, "TestName", sizeof(original_simple.name) - 1);
    original_simple.name[sizeof(original_simple.name) - 1] = '\0';

    uint8_t buffer_simple[256]; // Sufficient buffer for encoding
    CborEncoder encoder_simple;
    cbor_encoder_init(&encoder_simple, buffer_simple, sizeof(buffer_simple), 0);

    printf("Encoding SimpleData...\n");
    if (!encode_SimpleData(&original_simple, &encoder_simple)) {
        fprintf(stderr, "Failed to encode SimpleData!\n");
        return 1;
    }
    size_t encoded_len_simple = cbor_encoder_get_buffer_size(&encoder_simple, buffer_simple);
    printf("Encoded SimpleData length: %zu bytes\n", encoded_len_simple);
    print_cbor_hex(buffer_simple, encoded_len_simple);

    struct SimpleData decoded_simple;
    CborParser parser_simple;
    CborValue it_simple;

    printf("Decoding SimpleData...\n");
    CborError err_simple = cbor_parser_init(buffer_simple, encoded_len_simple, 0, &parser_simple, &it_simple);
    if (err_simple != CborNoError) {
        fprintf(stderr, "Failed to init parser for SimpleData: %d\n", err_simple);
        return 1;
    }
    if (!decode_SimpleData(&decoded_simple, &it_simple)) {
        fprintf(stderr, "Failed to decode SimpleData!\n");
        return 1;
    }

    printf("Verifying SimpleData...\n");
    assert(original_simple.id == decoded_simple.id);
    assert(strcmp(original_simple.name, decoded_simple.name) == 0);
    assert(original_simple.is_active == decoded_simple.is_active);
    // Floating point comparison needs tolerance
    assert(fabs(original_simple.temperature - decoded_simple.temperature) < 0.0001f);
    for (int i = 0; i < 4; ++i) {
        assert(original_simple.flags[i] == decoded_simple.flags[i]);
    }
    printf("SimpleData verification successful!\n\n");

    // --- Test NestedData ---
    struct NestedData original_nested;
    original_nested.inner_data = original_simple; // Copy simple data
    original_nested.value = 456;

    // Allocate buffer for description and copy string
    char description_buffer[MAX_DESCRIPTION_LEN];
    strncpy(description_buffer, "This is a nested description.", MAX_DESCRIPTION_LEN - 1);
    description_buffer[MAX_DESCRIPTION_LEN - 1] = '\0';
    original_nested.description = description_buffer;

    uint8_t buffer_nested[512]; // Sufficient buffer for encoding
    CborEncoder encoder_nested;
    cbor_encoder_init(&encoder_nested, buffer_nested, sizeof(buffer_nested), 0);

    printf("Encoding NestedData...\n");
    if (!encode_NestedData(&original_nested, &encoder_nested)) {
        fprintf(stderr, "Failed to encode NestedData!\n");
        return 1;
    }
    size_t encoded_len_nested = cbor_encoder_get_buffer_size(&encoder_nested, buffer_nested);
    printf("Encoded NestedData length: %zu bytes\n", encoded_len_nested);
    print_cbor_hex(buffer_nested, encoded_len_nested);

    struct NestedData decoded_nested;
    // For char* member, we need to pre-allocate the buffer for decoding
    char decoded_description_buffer[MAX_DESCRIPTION_LEN];
    decoded_nested.description = decoded_description_buffer;

    CborParser parser_nested;
    CborValue it_nested;

    printf("Decoding NestedData...\n");
    CborError err_nested = cbor_parser_init(buffer_nested, encoded_len_nested, 0, &parser_nested, &it_nested);
    if (err_nested != CborNoError) {
        fprintf(stderr, "Failed to init parser for NestedData: %d\n", err_nested);
        return 1;
    }
    if (!decode_NestedData(&decoded_nested, &it_nested)) {
        fprintf(stderr, "Failed to decode NestedData!\n");
        return 1;
    }

    printf("Verifying NestedData...\n");
    assert(original_nested.inner_data.id == decoded_nested.inner_data.id);
    assert(strcmp(original_nested.inner_data.name, decoded_nested.inner_data.name) == 0);
    assert(original_nested.inner_data.is_active == decoded_nested.inner_data.is_active);
    assert(fabs(original_nested.inner_data.temperature - decoded_nested.inner_data.temperature) < 0.0001f);
    for (int i = 0; i < 4; ++i) {
        assert(original_nested.inner_data.flags[i] == decoded_nested.inner_data.flags[i]);
    }
    assert(strcmp(original_nested.description, decoded_nested.description) == 0);
    assert(original_nested.value == decoded_nested.value);
    printf("NestedData verification successful!\n\n");

    printf("All tests passed!\n");
    return 0;
}
